#-------------------------------------------------------------------------------
# Name:        Euler_2
#
# Purpose:     Provides a solution to problem 1 on Project Euler which goes as
#              follows:
#
#              Each new term in the Fibonacci sequence is generated by adding
#              the previous two terms. By starting with 1 and 2,
#              the first 10 terms will be:
#
#                   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#
#              By considering the terms in the Fibonacci sequence whose
#              values do not exceed four million, find the sum of the
#              even-valued terms.
#
# Author:      Robert J. Cassidy
#
# Created:     22/01/2014
# Copyright:   (c) Robert J. Cassidy 2014
# Licence:     GNU-GPL
#-------------------------------------------------------------------------------

# This dictionary will store unique calculations made by fibonacci_generator
computed_fibonaccis = {}

# Initialized variable that will hold the sum of even valued fibonacci
# terms
sum_of_even_fibonaccis = 0

# Intializes the variable that will dictate what fibonacci term to generate.
# In this case will start at 1.
current_term = 1

# Initializes the variable that will terminate the loop in the main
# program once a value greater than it is returned. The problem specifies
# 4000000 to be this value.
upper_bound = 4000000

# Initializes the variable that remains false until upper_bound is exceeded
# by a returned value
exceeded = False
def main():
    # This function takes an integer value n to compute the n-th digit
    # of the fibonacci sequence. It employs a recursive algorithm to
    # calculate the requested n-th fibonacci number in conjuction with
    # memoization to enhance computation speed by cutting down on redundant
    # calculations. This function is only written to work with values
    # greater than 0.
    def fibonacci_generator(n):

        # Checks computed_fibonaccis first to see if the fibonacci of n has been
        # calculated already to avoid redundant calculation.
        if n in computed_fibonaccis:
            return computed_fibonaccis[n]
        else:
            if n==0:
                return 1
            if n==1:
                return 1
            else:
                return fibonacci_generator(n-1)+fibonacci_generator(n-2)

   # The following loop calls fibonacci_generator on each i starting at 1 and
   # and adds each returned number to sum_of_even_fibonaccis if even. Will
   # continue until fibonacci_generator returns a value greater than upper_bound
    while exceeded == False:

        global current_term
        global sum_of_even_fibonaccis

        # Holds value of calling fibonacci_generator on current_term for
        current_term_value = fibonacci_generator(current_term)

        if current_term_value <= upper_bound:
            # Adds the current_term_value to the dictionary of calculated
            # fibonaccis if it is not already contained within it.
            if current_term_value not in computed_fibonaccis:
                computed_fibonaccis.update({current_term:current_term_value})
            # Adds current_term_value to sum_of_even_fibonaccis if even.
            if current_term_value%2==0:
                sum_of_even_fibonaccis += current_term_value


        else:
            exceeded == True
            break
        current_term += 1

    # Prints answer contained in sum_of_even_fibonaccis to console
    print "The sum of all even valued fibonacci numbers less than"+\
    " four million is "+str(sum_of_even_fibonaccis)


if __name__ == '__main__':
    main()
